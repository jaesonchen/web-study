<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>advance.html</title>
    
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="cache-control" content="no-cache">
    <meta http-equiv="expires" content="0">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="keyword1,keyword2,keyword3">
    <meta name="description" content="this is my page">
    
    <script type="text/javascript" src="../assets/js/jquery-1.11.3.js"></script>
  </head>
  
  <body>
	<div id="div"></div>
    <script type="text/javascript">
    // <![CDATA[
    //如果你需要在没有硬编码的window标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：
    var global = (function () {
        return this;
    })();
    
    function show(msg, data) {
        $("#div").append($("<p></p>").text(msg + ": " + data));
    }

    //变量名需要遵守两条简单的规则：
    //•第一个字符必须是字母、下划线（_）或美元符号（$）
    //•余下的字符可以是下划线、美元符号或任何字母或数字字符
    //变量声明不是必须的
    //ECMAScript 另一个有趣的方面（也是与大多数程序设计语言的主要区别），是在使用变量之前不必声明。
    //ECMAScript 的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化为指定的值。
        
    //在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。
    //原始值存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。
    //引用值存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。
    //为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。
    //要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型。
    //在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。
    //如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。
    //相反，放在变量的栈空间中的值是该对象存储在堆中的地址。
        
    //typeof 运算符
    //对变量或值调用 typeof 运算符将返回下列值之一：
    //•undefined - 如果变量是 Undefined 类型的
    //•boolean - 如果变量是 Boolean 类型的
    //•number - 如果变量是 Number 类型的
    //•string - 如果变量是 String 类型的
    //•object - 如果变量是一种引用类型或 Null 类型的
    //null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
    //Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。
    //提示：值 undefined 并不同于未定义的变量。但是，typeof 运算符并不真正区分这两种值。
    //如果对未定义的变量 使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。
    //当函数无明确返回值时，返回的也是值 "undefined"
    show("typeof", typeof oTemp);     //undefined
    show("typeof null", typeof null);
    function testFunc() { }
    show("typeof return value", typeof testFunc());
        
    //Null 类型
    //另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。
    //尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。
    //如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。
    show("null == undefined", null == undefined);    //true
    show("null === undefined", null === undefined);  //false
        
    //Number 类型
    //ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示 32 位的整数，还可以表示 64 位的浮点数。
    //八进制字面量的首数字必须是 0
    //十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。
    //提示：尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。
    //几个特殊值也被定义为 Number 类型。 Number.MAX_VALUE 和 Number.MIN_VALUE，它们定义了 Number 值集合的外边界。
    //最后一个特殊值是 NaN，表示非数（Not a Number）。NaN 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。
    //NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等。出于这个原因，不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好。
    show("NaN == NaN", [NaN == NaN, isNaN("blue")]);  //false true
	        
    //String 类型的独特之处在于，它是唯一没有固定大小的原始类型。
    //字符串字面量是由双引号（"）或单引号（'）声明的。
    //ECMAScript 的字符字面量：
    //\n 换行 
    //\t 制表符 
    //\b 空格 
    //\r 回车 
    //\\ 反斜杠 
    //\' 单引号 
    //\" 双引号 
    show("String", "aa\'cc\r\ncc\\\"");     // aa'cc cc\"
        
    //ECMAScript 类型转换
    //ECMAScript 给开发者提供了大量简单的类型转换方法。
    //大部分类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。无论哪种情况，在 ECMAScript 中，类型转换都是简短的一步操作。
    //ECMAScript 的 Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。
    //Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值。
    //注释：在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。
    //采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。
    var iNum = 100;
    show("Number.toString", [iNum.toString(), iNum.toString(2), iNum.toString(8), iNum.toString(16)]);
        
    //ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 parseInt() 和 parseFloat()。
    //前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。
    //parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。
    //但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。
    //这一过程将持续到发现非有效数字的字符为止，此时 parseInt() 将把该字符之前的字符串转换成数字。
    show("parseInt", [parseInt("a1234abcd"), parseInt("1234abcd"), parseInt("1234.34aa")]);
    //第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。
    show("parseFloat", [parseFloat("11.2a2"), parseFloat("11.22.33")]);
        
    //您还可以使用强制类型转换（type casting）来处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。
    //ECMAScript 中可用的 3 种强制类型转换如下：
    //•Boolean(value) - 把给定的值转换成 Boolean 型
    //•Number(value) - 把给定的值转换成数字（可以是整数或浮点数）
    //•String(value) - 把给定的值转换成字符串
    //Boolean() 函数:当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。
    show("new Boolean()", [Boolean(""), Boolean(null), Boolean(undefined), Boolean(0), Boolean(-0), 
                           Boolean(50), Boolean("hello"), Boolean(new Object())]);  //false,false,false,false,true,true,true
    //Number() 函数:与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。
    show("new Number()", [Number(false), Number(true), Number(null), Number("1.2"), Number(undefined), Number("1.2.3"), Number(new Object())]); //0,1,0,1.2,NaN,NaN,NaN
    //String() 函数:强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误：null.toString() 会引发错误
    show("new String()", [String(null), String(undefined)]);    //null,undefined

    //ECMAScript 引用类型
    //引用类型通常叫做类（class）。
    //注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。
    //ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。
    //对象是由 new 运算符加上要实例化的对象的名字创建的。
    //当有不止一个参数时，ECMAScript 要求使用括号。如果没有参数，括号可以省略：注意：尽管括号不是必需的，但是为了避免混乱，最好使用括号。
        
    //Object 对象(每种属性和方法都会被其他对象覆盖)
    //ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。
    //Object 对象具有下列属性：
    //constructor 对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 构造函数。
    //prototype 对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。
    //Object 对象还具有几个方法：
    //hasOwnProperty(property) 判断对象是否有某个特定的属性。必须用字符串指定该属性。
    //isPrototypeOf(object) 判断该对象是否为另一个对象的原型。
    //propertyIsEnumerable 判断给定的属性是否可以用 for...in 语句进行枚举。
    //toString() 返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。
    //valueOf() 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 toString() 的返回值相同。

        
    //Boolean 对象是 Boolean 原始类型的引用类型。
    //Boolean 对象将覆盖 Object 对象的 valueOf() 方法，返回原始值，即 true 和 false，toString() 方法也会被覆盖，返回字符串 "true" 或 "false"。
    //在 Boolean 表达式中，所有对象都会被自动转换为 true，所以 oFalseObject 的值是 true。
    var oFalseObject = new Boolean(false);
    show("Boolean", oFalseObject && true);     //true
        
    //Number 对象是 Number 原始类型的引用类型。
    var oNumberObject = new Number(168);
    //toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。
    //toExponential() 方法返回的是用科学计数法表示的数字的字符串形式。
    //toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。
    //toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 
    show("Number", [oNumberObject.toFixed(2), oNumberObject.toExponential(3), oNumberObject.toPrecision(4)]); //168.00,1.680e+2,168.0
        
    //String 对象是 String 原始类型的对象表示法
    //String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值
    var oStringObject = new String("hello world");
    show("String", [oStringObject.valueOf() == oStringObject.toString(), oStringObject == "hello world", oStringObject === "hello world"]);    //true,true,false
    //length 属性:String 对象具有属性 length，它是字符串中的字符个数
    //注意，JavaScript 使用UTF-16 编码，，该编码使用一个 2字节的编码单元来表示大部分常见的字符，使用两个编码单元表示不常用的字符。
    //因此 length 返回值可能与字符串中实际的字符数量不相同。
    show("String.length", [oStringObject.length, "你好".length]); //11, 2
    //charAt() 和 charCodeAt() 方法: 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。
    //charAt() 方法返回的是指定位置处的字符。charCodeAt()得到的是字符编码。
    show("charAt()", [oStringObject.charAt(1), oStringObject.charCodeAt(1), "你好".charAt(1), "你好".charCodeAt(1)]); //e,101,好,22909
    //concat() 方法:用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是新的 String 原始值，保持原始的 String 对象不变。
    show("concat()", [oStringObject.concat(" jaeson"), oStringObject]);
    //出于这种原因，较常见的是用加号（+）连接字符串，因为这种形式从逻辑上表明了真正的行为：
    show(" + ", [oStringObject + " jaeson", oStringObject]);
    //indexOf() 和 lastIndexOf() 方法:返回的都是指定的子串在另一个字符串中的位置，如果没有找不到子串，则返回 -1。
    //这两个方法的不同之处在于，indexOf() 方法是从字符串的开头（位置 0）开始检索字符串，而 lastIndexOf() 方法则是从字符串的结尾开始检索子串。
    show("indexOf()", [oStringObject.indexOf("o"), oStringObject.lastIndexOf("o")]);
    //localeCompare() 方法: 对字符串进行排序。
    //•如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。
    //•如果 String 对象等于参数中的字符串，返回 0
    //•如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。
    //注释：如果返回负数，最常见的是 -1，返回正数，最常见的是 1，不过真正返回的值由浏览器实现决定的。
    //localeCompare() 是区分大小写的，大写字母在字母顺序上排在小写字母之后。
    show("localeCompare()", [oStringObject.localeCompare("brick"), oStringObject.localeCompare("hello world"), 
                             oStringObject.localeCompare("zero")]);  //1,0,-1
    //slice() 和 substring()
    //这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，
    //第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。
    //如果省略第二个参数，终止位就默认为字符串的长度。
    //slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。
    show("slice() 和 substring()", [oStringObject.slice(3), oStringObject.slice(3, 7), oStringObject.substring(3), oStringObject.substring(3, 7)]);
    //事实上，这两个方法并不完全相同，不过只在参数为负数时，它们处理参数的方式才稍有不同。
    //对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。
    //如果后面的参数小于前面的参数，slice返回空串，substring会将2个参数对调， substring() 总把较小的数字作为起始位，较大的数字作为终止位。
    show("slice() 和 substring()", [oStringObject.slice(3, -4), oStringObject.substring(3, -100)]);
    //toLowerCase()、toUpperCase()
    show("toLowerCase() 和 toUpperCase()", [oStringObject.toUpperCase(), oStringObject.toLowerCase(), oStringObject]);
        
    //instanceof 运算符
    //在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 "object"。
    //ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。
    show("typeof", [typeof new Boolean(), typeof new String(), typeof new Number()]); //object,object,object
    //instanceof 方法要求开发者明确地确认对象为某特定类型。
    show("instanceof", [new Boolean() instanceof Boolean, new String() instanceof String, new String() instanceof Object, 
                10 instanceof Number, "String" instanceof String, false instanceof Boolean, "String" instanceof Object]);
    //true,true,true,false,false,false,false

    // ]]>
    </script>
  </body>
</html>
